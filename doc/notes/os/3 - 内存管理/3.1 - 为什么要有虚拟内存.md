## 虚拟内存

单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。

另外，***单片机的 CPU 是直接操作内存的「物理地址」***。

在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 0x2000
的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

操作系统可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的。

两种地址的概念：

* 我们程序所使用的内存地址叫做 ***虚拟内存地址（Virtual Memory Address）***
* 实际存在硬件里面的空间地址叫 ***物理内存地址（Physical Memory Address）***

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的 ***内存管理单元（MMU）*** 的映射关系，来转换变成物理地址，然后再通过物理地址访问内存

## 操作系统是如何管理虚拟地址与物理地址之间的关系

### 内存分段

分段机制下的虚拟地址由两部分组成， ***段选择因子*** 和 ***段内偏移量***

* ***段选择因子*** 就保存在段寄存器里面。段选择子里面最重要的是 ***段号***，用作段表的索引。***段表*** 里面保存的是这个
  ***段的基地址***、***段的界限和特权等级*** 等。
* 虚拟地址中的 ***段内偏移*** 量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

不足之处：

* 第一个就是内存碎片的问题，***会出现段外内存碎片***。
* 第二个就是内存交换的效率低的问题，***换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿***。

### 内存分页

当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是
***内存分页（Paging）***

***分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小***。这样一个连续并且尺寸固定的内存空间，我们叫 ***页（Page）***。在
Linux 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过 ***页表*** 来映射。

页表是存储在内存里的， ***内存管理单元 （MMU）*** 就做将虚拟内存地址转换成物理地址的工作。

***采用了分页，页与页之间是紧密排列的，所以不会有外部碎片***。

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为
***换出（Swap Out）***。一旦需要的时候，再加载进来，称为 ***换入（Swap In）***。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，
***内存交换的效率就相对比较高***。

#### 多级页表

***如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表***。

***页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项***
（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。

#### TLB

CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer）
，通常称为页表缓存、转址旁路缓存、快表等。

### 段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为***段页式内存管理***。

段页式内存管理实现的方式：

* 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
* 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

这样，地址结构就由 ***段号、段内页号和页内位移*** 三部分组成。

段页式地址变换中要得到物理地址须经过三次内存访问：

* 第一次访问段表，得到页表起始地址；
* 第二次访问页表，得到物理页号；
* 第三次将物理页号与页内位移组合，得到物理地址。

### Linux 内存布局

Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux
系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。

* 32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；
* 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。

每个进程都各自有独立的虚拟内存，但是 ***每个虚拟内存中的内核地址，其实关联的都是相同的物理内存***
。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

#### 用户空间分布的情况，以 32 位系统为例

![](../images/32位虚拟内存布局.webp)

用户空间内存，从低到高分别是 6 种不同的内存段：

* 代码段，包括二进制可执行代码；
* 数据段，包括已初始化的静态常量和全局变量；
* BSS 段，包括未初始化的静态变量和全局变量；
* 堆段，包括动态分配的内存，从低地址开始向上增长；
* 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 (opens new window)）；
* 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；

代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在
C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现
bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。

