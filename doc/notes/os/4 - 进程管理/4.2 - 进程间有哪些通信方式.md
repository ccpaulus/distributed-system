进程间通信方式：

* 管道
    * Linux 命令，「|」，***匿名管道***，用完了就销毁，通信范围是存在父子关系的进程。传输数据是单向的，如果想相互通信，需要创建两个管道才行。
    * 管道还有另外一个类型是命名管道，也被叫做 FIFO，因为数据是先进先出的传输方式，使用 `mkfifo`
      命令来创建，并且指定管道名字，可以在不相关的进程间也能相互通信。
    * 不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候也是从内核中获取。
    * 效率低，不适合进程间频繁地交换数据。
* 消息队列
    * 消息队列是保存在内核中的消息链表。
    * 消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。
    * 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。
* 共享内存
    * 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来，大大提高了进程间通信的速度。
* 信号量
    * 用了共享内存通信方式，如果多个进程同时修改同一个共享内存，很有可能就冲突了。为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这一保护机制。
    * 信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。
    * 信号量表示资源的数量，控制信号量的方式有两种原子操作：
        * P 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >=
          0，则表明还有资源可使用，进程可正常继续执行。
        * V 操作，这个操作会把信号量加上 1，相加后如果信号量 <=
          0，则表明当前有阻塞中的进程，于是会将阻塞中的进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程。
    * 信号量也同样可以在线程间实现互斥与同步。
        * 互斥的方式，可保证任意时刻只有一个线程访问共享资源。
        * 同步的方式，可保证线程 A 应在线程 B 之前执行。
* 信号
    * 对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。
    * 信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别。
    * 在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号。
    * 信号是异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件。
    * 一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。
* Socket
    * 如果要与不同主机的进程间通信，那么就需要 Socket 通信了。
    * Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于
      TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。
    * 本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。

