# Timely Stream Processing

实时流处理是有状态流处理的扩展，在有状态流处理中，时间在计算中起着一定的作用。
比如：在进行时间序列分析、基于特定时间段(通常称为窗口)进行聚合或进行事件处理(其中事件发生的时间很重要)时。

## 时间的概念:事件时间（Event Time）和处理时间（Processing Time）

* Processing Time：`处理时间`是指执行相应操作的机器的系统时间。
  <br/>当流程序以`处理时间`运行时，所有基于时间的操作(如时间窗口)将使用运行相应`operator`的机器的`系统时钟`。
  每小时处理时间窗口将包括在系统时钟指示整小时之间到达特定`operator`的所有记录。
  例如，如果应用程序在上午9:15开始运行，那么第一个小时处理时间窗口将包括上午9:15到上午10:
  00之间处理的事件，下一个窗口将包括上午10:00到上午11:00之间处理的事件，依此类推。
  <br/>处理时间是最简单的时间概念，不需要流和机器之间的协调。它提供了最好的性能和最低的延迟。
  然而，在分布式和异步环境中，处理时间无法提供确定性，因为它容易受到记录到达系统的速度(例如来自消息队列)
  、记录在系统内`operators`之间流动的速度以及中断(计划的或其他)的影响。
* Event time：`事件时间`是每个单独事件在其产生设备上发生的时间。这个时间通常在记录进入Flink之前嵌入到记录中，并且可以从每个记录中提取事件时间戳。
  在事件时间中，时间的进展取决于数据，而不是任何挂钟。事件时间程序必须指定如何生成事件时间`Watermarks`，这是在事件时间中指示进展的机制。
  <br/>在理想情况下，事件时间处理将产生完全一致和确定的结果，而不管事件何时到达或它们的顺序如何。
  但是，除非已知事件是按顺序到达的(按时间戳)，否则在等待乱序事件时，事件时间处理会导致一些`延迟`。
  由于只能等待一段有限的时间，这就限制了事件时间应用程序的确定性。
  <br/><span style="color:orange; ">请注意，有时当事件时间程序实时处理实时数据时，它们将使用一些处理时间操作，以确保它们及时地进行处理。
  </span>

![](images/timely/event_processing_time.svg)

## Event Time and Watermarks

支持`事件时间`的流处理器需要一种方法来度量事件时间的`进度`。例如，构建小时窗口的窗口`operator`
需要在事件时间超过一小时结束时得到通知，以便`operator`可以关闭正在进行的窗口。

`事件时间`可以独立于`处理时间(由挂钟测量)`进行。
例如，在一个程序中，`operator`的当前事件时间可能稍微落后于处理时间(考虑到接收事件的延迟)，而两者以相同的速度进行。
另一方面，另一个流程序可能通过快速转发已经缓冲在`Kafka topic`(或另一个消息队列)中的一些历史数据来处理`几周`
的事件时间，而只需要`几秒钟`的处理时间。

Flink中测量事件时间进展的机制是`watermarks`。`watermarks`作为数据流的一部分，并携带`时间戳t`。
`Watermark(t)`声明事件时间在该流中已达到时间t，这意味着流中不应该再有`时间戳 t' <= t`的元素(即时间戳较早或等于`watermark`
的事件)。

下图显示了带有(逻辑)时间戳和内联`watermarks`的事件流。在本例中，事件是按顺序排列的(相对于它们的时间戳)
，这意味着`watermarks`只是流中的周期性标记。

![](images/timely/stream_watermark_in_order.svg)

`Watermarks`对于`乱序流`是至关重要的，如下图所示，其中事件不是按时间戳排序的。
一般来说，`watermark`是一种声明，声明到流中的那个点，在某个时间戳之前的所有事件都应该已经到达。
一旦`watermark`到达一个`operator`，`operator`可以将其内部事件时钟提前到`watermark`的值。

![](images/timely/stream_watermark_out_of_order.svg)

<span style="color:orange; ">请注意，事件时间由新创建的`流元素(或多个元素)`
继承，这些元素要么来自`产生它们的事件`，要么来自`触发这些元素创建的 watermark`。</span>

### Watermarks in Parallel Streams

`Watermarks`是在`source functions`处或直接在`source functions`之后生成的。
`source function`的每个并行子任务通常独立地生成其`watermarks`。这些`watermarks`定义了特定并行源处的`事件时间`。

当`watermarks`在流式程序中流动时，一旦它们到达了`operators`，就会推进`operators`的事件时间。
每当一个`operator`将其事件时间向前推进时，它就会在下游为`后续operator`生成新的`watermark`。

一些`operators`会使用多个输入流；例如，`union`或`keyBy()`或`partition()`函数后面的`operators`。
这样的`operator`的`当前事件时间`是其`输入流事件时间`的`最小值`。当它的输入流更新它们的事件时间时，`operator`也会进行更新。

下图显示了在并行流中流动的事件和`watermarks`的示例，以及跟踪事件时间的`operators`。

![](images/timely/parallel_streams_watermarks.svg)

## Lateness

某些元素可能会违反`watermark`条件，这意味着即使在`Watermark(t)`出现之后，还会出现更多`时间戳 t' <= t`的元素。
事实上，在许多现实世界的设置中，某些元素可以任意延迟，因此不可能指定`某个事件时间戳的所有元素`出现的时间。
此外，即使延迟可以被限制，过多地去延迟`watermarks`通常也是不可取的，因为它会在事件时间窗的评估中导致了太大的延迟。

出于这个原因，流式程序可能会明确地期待一些`延迟元素`。`延迟元素`是在`系统事件时钟(由 watermarks 表示)`
之后到达的元素，此时的系统的事件时间时钟已经超过了`延迟元素的时间戳`。

## Windowing

聚合事件(例如计数、求和)在流处理中的工作方式与批处理中的不同。
例如，计算流中的所有元素是不可能的，因为流通常是无限的。相反，流上的聚合(counts、sums等)是由窗口限定的，比如最近5分钟的计数，或者最近100个元素的总和。

Windows可以是`时间驱动`的(例如:每30秒)或`数据驱动`的(例如:每100个元素)。
通常可以区分不同类型的窗口，例如滚动窗口(没有重叠)、滑动窗口(有重叠)和会话窗口(被不活动的间隙打断)。

![](images/timely/windows.svg)

