# Performance Overview

## 关于Java性能的误解

随着Java版本的持续迭代，`坊间传闻`或`搜索引擎`置顶的文章，因为过时性，给Java调优带来了令人误解的副作用。
<br/>
<span style="color:green; ">Java性能调优需要根据不同版本，实际情况实际分析。</span>

## Java性能概述

~~~
Java 是一门蓝领语言。它不是博士论文材料，而是用于工作的语言。   --java之父 James Gosling
~~~

Java 讲究实用性，对于性能的态度是，只要`环境足够快`且能`提升开发效率`，就可以牺牲原始性能。
随着JVM的日趋成熟和进步，Java环境才开始适合高性能计算的应用程序。

实用性：Java实用性最最明显的一点是使用了`托管子系统`。其理念是，开发人员无须关心托管环境的某些细节，而代价是放弃对底层的一些控制，比如：内存管理。

<span style="color:orange; ">我们很容易被Java性能测量值误导，因为环境的复杂性意味着很难隔离系统的各个方面。</span>
<br/>
<span style="color:orange; ">测量也有成本，频繁采样（记录每个结果）可能会对所记录的性能数字造成明显的影响。
Java性能测量需要使用一些复杂的统计方法，这经常会产生不正确的结果。</span>

JVM具有高度优化和自适应的特性，所以使用Java构建的生产系统有时会表现出一些非常微妙且复杂的性能行为。硬件能力的空前提升对Java性能复杂性有显著的影响。

## 性能测量

### 性能测量方法：

* 定义期望的结果
* 测量现有的系统
* 确定要实现需求所需的工作
* 开始某个改进操作
* 重新测试
* 确定目标是否实现

### 性能分类：

* 吞吐量（throughput）
  吞吐量用某个时间段内的工作单元数来表示。比如：系统每秒能执行多少个事务。
* 延迟（latency）
  端到端的时间。
* 容量（capacity）
  系统的工作并行度，及系统可以同时进行的工作单元（比如事务）数量。容量通常被看作在给定延迟或吞吐量下的可用处理能力。
* 利用率（utilization）
  系统资源的使用情况。比如CPU使用率。不同的工作负载下，不同的资源利用水平可能差异巨大。
  比如，计算密集型工作负载（图形处理|加密）运行时，CPU利用率100%，但内存仅使用了一小部分。
* 效率（efficiency）
  给定吞吐量下，所用资源的多少来衡量系统的整体效率。即资源成本。
* 可扩展性（scalability）
  系统的吞吐量取决于可用的处理资源。吞吐量的变化与资源的变化步调一致。比如集群规模扩大一倍，吞吐量加一倍，则系统成线性扩展。
* 降级（degradation）
  增加系统的工作负载（如增加客户端数量），系统延迟或吞吐量的变化。系统利用率不高，则吞吐量或延迟变化平缓；系统资源已经充分利用，则吞吐量停止增加或延迟增加。
  这种变化被称为系统在额外负载下的降级。

### 各种性能观测之间的关联

各种性能观测行为通常会以某种方式关联在一起。这种关系的细节取决于系统是否在峰值利用率运行。比如，一般情况下，利用率会随着系统负载的增加而改变。
然而，如果系统的利用率不足，那么增加负载未必会明显提高利用率。

另一个例子，可扩展性和降级都代表系统行为在负载增加时的变化。
对于可扩展性来说，负载增加，资源也会增加，需要关心的核心问题是系统能否利用增加的资源。
而如果负载增加了，却没有提供额外的资源，那可观测到的性能降级（比如延迟）就可以预料了。

有些情况下，额外的负载会引发出乎预料的结果，如HotSpot的JIT编译器。低负载时，因为执行不频繁，有些关键方法会在解释模式下执行。
而高负载时，由于执行足够频繁，而进行了编译，从而使得执行效率更高，速度更快。

<span style="color:green; ">
系统对于性能指标的要求，会因为需求场景而异。需要大吞吐量的场景，延迟可能不敏感；需要低延迟的场景，吞吐量可能不大。</span>

### 性能拐点

随着负载的增加，性能出现了突然的、预料之外的降级，这通常叫做`性能拐点`。
